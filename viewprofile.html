<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Profile</title>

  <!-- Firebase compat (works with other pages that use compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.11.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.11.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore-compat.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#171717;
      --card:#1f1f1f;
      --muted:#9ca3af;
      --accent:#6b21a8;
      --accent-strong:#5b21b6;
      --text:#eaeaea;
      --border:rgba(255,255,255,0.06);
      --danger:#c01b1b;
      --danger-dark:#6a0f0f; /* darker red text */
      --white-btn-bg: rgba(255,255,255,0.03);
      --btn-border-muted: rgba(255,255,255,0.04);
    }
    body.light{
      --bg:#f6f8fb; --card:#fff; --muted:#475569; --text:#0f172a; --border:rgba(0,0,0,0.06);
      --white-btn-bg: rgba(0,0,0,0.04);
    }

    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased;box-sizing:border-box;overflow-x:hidden;}
    body{display:flex;flex-direction:column;min-height:100vh;}

    dp-topbar{display:block;position:sticky;top:0;z-index:100;}

    main.container{max-width:1100px;margin:22px auto;padding:20px;display:grid;grid-template-columns:1fr 360px;gap:20px;box-sizing:border-box;}
    @media (max-width:920px){ main.container{grid-template-columns:1fr;padding:16px 12px;} }
    @media (max-width:740px){ main.container{grid-template-columns:1fr; } }

    .card{background:var(--card);border-radius:12px;padding:18px;border:1px solid var(--border);box-shadow:0 6px 18px rgba(2,6,23,0.45);color:var(--text);}

    .heading { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px; }
    .title { font-size:18px; font-weight:700; margin:0; }
    .subtitle { color:var(--muted); font-size:13px; margin-top:6px; }

    .banner { width:100%; height:160px; border-radius:10px; background: #2a2a2a center/cover no-repeat; display:block; border:1px solid var(--border); }
    .profile-row { display:flex; gap:18px; align-items:flex-start; margin-top:14px; flex-wrap:wrap; }
    .pfp-wrap { position:relative; width:120px; flex:0 0 120px; }
    .pfp { width:120px;   background-repeat: no-repeat;height:120px; border-radius:14px; background-size:cover; background-position:center; border:1px solid var(--border); }
    .pfp-frame { position:absolute; inset:0; border-radius:14px; pointer-events:none; display:none; }

    .meta { flex:1; min-width:220px; }
    .display-name { font-size:20px; font-weight:700; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .verified { width:18px; height:18px; background-image:url('/assets/verified.png'); background-size:contain; background-repeat:no-repeat; display:inline-block; }
    .email { color:var(--muted); font-size:13px; margin-top:6px; word-break:break-all; }
    .bio { margin-top:12px; color:var(--text); line-height:1.4; }
    .small-muted { color:var(--muted); font-size:13px; margin-top:8px; }

    .controls { margin-top:14px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .btn { padding:8px 12px; border-radius:8px; border:1px solid var(--btn-border-muted); background:var(--white-btn-bg); color:var(--text); cursor:pointer; font-weight:600; min-height:36px; display:inline-flex; gap:8px; align-items:center; }
    .btn.primary { background:var(--accent); color:#fff; border:none; }
    .btn.ghost { background:transparent; }
    /* destructive/text-only red: keep the same button background but red text and slightly stronger border */
    .btn.red { background:var(--white-btn-bg); color:var(--danger-dark); border:1px solid rgba(106,15,15,0.13); }
    .btn.iconless { padding-left:12px; }
    .field-row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-top:8px; }

    .list { display:flex; flex-direction:column; gap:8px; margin-top:8px; }

    .role-item { display:flex; gap:10px; align-items:center; }
    .role-item img { width:30px; height:30px; object-fit:cover; border-radius:3px; }

    #toast { position:fixed; top:18px; left:50%; transform:translateX(-50%); padding:10px 14px; border-radius:10px; font-weight:700; display:none; z-index:99999; color:#fff; }
    #toast.purple{ background:var(--accent-strong); } #toast.red{ background:#c00; } #toast.yellow{ background:#e6b800; color:#222; }

    .stats-row { display:flex; gap:14px; margin-top:10px; align-items:center; flex-wrap:wrap; }
    .stat { background:transparent; border-radius:8px; padding:8px 10px; border:1px solid var(--border); color:var(--muted); font-weight:600; font-size:13px; }

    .right-column .card + .card { margin-top:12px; }

    .actions-vertical { display:flex; flex-direction:column; gap:10px; margin-top:6px; }
    .muted { color:var(--muted); }

    /* ensures no horizontal scroll */
    html,body { overflow-x:hidden; }
  </style>
</head>
<body>
  <script type="module" src="/dp-topbar.js"></script>
  <dp-topbar></dp-topbar>

  <main class="container" role="main" aria-label="View profile">
    <section class="card">
      <div class="heading">
        <div>
          <div class="title" id="page-title">Profile</div>
          <div class="subtitle">Public user information</div>
        </div>
        <div class="muted" id="last-updated"> </div>
      </div>

      <div id="banner" class="banner" title="Profile banner"></div>

      <div class="profile-row">
        <div class="pfp-wrap">
          <div id="profile-pic" class="pfp" title="Profile picture"></div>
          <div id="pfp-frame" class="pfp-frame"></div>
        </div>

        <div class="meta">
          <div class="display-name">
            <div id="display-name">Loading…</div>
            <div id="verified" class="verified" title="Verified" style="display:none;"></div>
          </div>
          <div id="email" class="email"></div>

          <div class="bio">
            <strong>Bio</strong>
            <div id="bio-text" style="margin-top:8px;">Loading…</div>
          </div>

          <div class="stats-row" id="counters">
            <div class="stat" id="followers-count">Followers: 0</div>
            <div class="stat" id="following-count">Following: 0</div>
            <div class="stat" id="friends-count">Friends: 0</div>
          </div>

          <div class="small-muted" style="margin-top:10px">Roles & info:</div>
          <div id="rolesList" class="list"></div>
          <div class="small-muted" style="margin-top:8px">Note: some roles don't have icons and won't be visible here — see additional roles in the app for the full list.</div>
        </div>
      </div>
    </section>

    <aside class="right-column">
      <div class="card">
        <div style="font-weight:700">Profile Details</div>
        <div class="small-muted" style="margin-top:8px" id="detailsList">
          Loading…
        </div>
      </div>

      <div class="card">
        <div style="font-weight:700">About special posts</div>
        <div class="small-muted" style="margin-top:8px">
          To view special post categories you'll need to use the app. You can still view this user's regular posts in the Posts section. Development Items and Store entries are coming very soon.
        </div>
      </div>

      <!-- interactions moved to right column below special posts -->
      <div id="interactionArea" class="card" style="margin-top:12px; padding:12px;">
        <div style="font-weight:700">Interactions</div>
        <div id="interactionButtons" class="actions-vertical" style="margin-top:10px;">
          <div style="color:var(--muted)">Loading actions…</div>
        </div>
      </div>

    </aside>
  </main>

  <div id="toast" role="status" aria-live="polite"></div>

  <script>
    // Firebase init (compat)
    const firebaseConfig = {
      apiKey: "AIzaSyCAPZF2zwU6z5rhikrIVZ4TVxf1tS5aTbA",
      authDomain: "darkpurpleof-s-website.firebaseapp.com",
      projectId: "darkpurpleof-s-website",
      storageBucket: "darkpurpleof-s-website.firebasestorage.app",
      messagingSenderId: "520651082420",
      appId: "1:520651082420:web:bb05c0c3fd64517952e5e1"
    };
    if (!window.firebase || !firebase.apps.length) firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // role map provided by user
    const roleMap = {
      "Administrator": { icon: "/assets/ic_admin.webp", desc: "Official Administrator of the platform, can manage users" },
      "Member": { icon: "/assets/ic_member.webp", desc: "Normal member of the platform" },
      "(Creator) English": { icon: "/assets/us.png", desc: "Helped translate the app into English, creator of the app!" },
      "German helper": { icon: "/assets/de.png", desc: "User who translated the app into German" },
      "Spanish Helper": { icon: "/assets/es.png", desc: "User who translated the app into Spanish" },
      "Japanese Helper": { icon: "/assets/jp.png", desc: "User who translated the app into Japanese" },
      "Russian Helper": { icon: "/assets/ru.png", desc: "User who translated the app into Russian" },
      "Owner": { icon: "/assets/ic_owner.webp", desc: "The owner of the DarkPurpleOF's website!, official account, it's me DarkPurple!" },
      "Tester": { icon: "/assets/test.png", desc: "User who tested the app before its official release" },
      "Legacy User": { icon: "/assets/legacy.png", desc: "Users registered on the platform prior to December 2024" },
      "System": { icon: "/assets/ic_system.webp", desc: "Official system account!" },
      "Elite User": { icon: "/assets/elite.png", desc: "Users whose actions or contributions have been deeply known in the platform" },
      "Feedback Contributor": { icon: "/assets/feedback.png", desc: "Users whose contributions or ideas have been added to the app or website" },
      "Unbannable": { icon: "/assets/ic_unbannable.webp", desc: "Users who can't be banned by moderation tools or the system" }
    };

    // DOM refs
    const bannerEl = document.getElementById('banner');
    const profilePicEl = document.getElementById('profile-pic');
    const pfpFrameEl = document.getElementById('pfp-frame');
    const displayNameEl = document.getElementById('display-name');
    const emailEl = document.getElementById('email');
    const verifiedEl = document.getElementById('verified');
    const bioTextEl = document.getElementById('bio-text');
    const rolesList = document.getElementById('rolesList');
    const lastUpdatedEl = document.getElementById('last-updated');
    const detailsList = document.getElementById('detailsList');
    const interactionButtons = document.getElementById('interactionButtons');
    const interactionArea = document.getElementById('interactionArea');
    const followersCountEl = document.getElementById('followers-count');
    const followingCountEl = document.getElementById('following-count');
    const friendsCountEl = document.getElementById('friends-count');

    const toastEl = document.getElementById('toast');
    function showToast(msg, color='purple', duration=3000){ toastEl.textContent = msg; toastEl.className = color; toastEl.style.display='block'; setTimeout(()=>{ toastEl.style.display='none'; toastEl.className=''; }, duration); }

    // helper: read URL param "profile"
    function getProfileParam(){
      const params = new URLSearchParams(window.location.search);
      const p = params.get('profile');
      return p ? decodeURIComponent(p) : null;
    }

    // fallback values per user request
    function fallbackProfile(emailArg){
      return {
        displayName: "No Display Name",
        email: emailArg,
        profile_picture: '/org-owner.jpg',
        banner: '/assets/def_banner.png',
        bannedBanner: '/assets/def_banner.png',
        roles: ['Member'],
        bio: "No bio available",
        is_verified: false,
        profile_picture_frame: ''
      };
    }

    // sanitize doc id if necessary (current codebase uses plain emails as doc ids)
    function docIdFromEmail(email){ return email; }

    // permission-denied tracking per-listener key
    const permissionDeniedFor = {};

    // relationship state cache
    let relationshipState = {
      isBlockedByCurrent: false,
      hasBlockedCurrent: false,
      isFollowing: false,
      isFollowedBy: false,
      friendExists: false,
      requestSent: false,
      requestReceived: false
    };

    let currentUser = null;
    let viewedEmail = null;
    let viewedData = null;
    let isFallbackProfile = false;


    // subscription handles to unsubscribe on change
    let unsubscribes = [];

    function clearUnsubscribes(){
      for(const u of unsubscribes){
        try { if (typeof u === 'function') u(); } catch(e){ /* ignore */ }
      }
      unsubscribes = [];
    }

    // check for Firestore permission errors
    function isFirestorePermissionError(err){
      if (!err) return false;
      try {
        if (err.code === 'permission-denied' || err.code === 'PERMISSION_DENIED') return true;
        const msg = String(err.message || err);
        if (/missing|insufficient permissions|permission-denied/i.test(msg)) return true;
      } catch(e){ }
      return false;
    }

    function renderProfileFallbackFields(emailArg, reason){
      // only replace profile fields — do NOT hide interactions
      console.warn('Rendering fallback profile fields for', emailArg, 'reason:', reason);
      const fb = fallbackProfile(emailArg);
      viewedData = fb;

      bannerEl.style.backgroundImage = `url(${fb.banner})`;
      isFallbackProfile = true;
      profilePicEl.style.backgroundImage = `url(${fb.profile_picture})`;
      displayNameEl.textContent = fb.displayName;
      emailEl.textContent = fb.email;
      bioTextEl.textContent = fb.bio;
      verifiedEl.style.display = fb.is_verified ? 'inline-block' : 'none';
      pfpFrameEl.style.display = 'none';

      // roles
      rolesList.innerHTML = '';
      (fb.roles || []).forEach(r => {
        const el = document.createElement('div');
        el.className = 'role-item muted';
        if (roleMap[r]){
          const img = document.createElement('img'); img.src = roleMap[r].icon; img.alt = r; img.title = `${r} — ${roleMap[r].desc}`; el.appendChild(img);
          const txt = document.createElement('div'); txt.textContent = r; el.appendChild(txt);
        } else {
          el.textContent = r;
        }
        rolesList.appendChild(el);
      });

      detailsList.innerHTML = '';
      const dlist = [
        `<div><strong>Profile email:</strong> ${escapeHtml(fb.email)}</div>`,
        `<div><strong>Verified:</strong> ${fb.is_verified ? 'Yes' : 'No'}</div>`,
        `<div style=\"color:var(--muted);margin-top:6px;\">Limited access.</div>`
      ];
      detailsList.innerHTML = dlist.join('');

      showToast('Limited access', 'yellow', 4500);
    }

    function handleFirestoreError(err, emailArg, key){
      console.error('Firestore listener error for', key, err);
      if (isFirestorePermissionError(err)){
        // mark which listener had permission issues
        permissionDeniedFor[key] = true;
        // special case: if main profile doc is denied, show fallback fields
        if (key === 'viewedUser') {
          renderProfileFallbackFields(emailArg || viewedEmail, err && err.message ? err.message : 'permission error');
        } else {
          // for other listeners just update UI indicators and keep interactions available
          if (key === 'followers') followersCountEl.textContent = 'Followers: —';
          if (key === 'following') followingCountEl.textContent = 'Following: —';
          if (key === 'friends') friendsCountEl.textContent = 'Friends: —';
          if (key === 'friendDocs' || key === 'friendExists') relationshipState.friendExists = false;
          // show a small toast but not the big fallback
        }
        // re-render buttons so permissions apply
        renderInteractionButtons();
      } else {
        // non-permission error: log and show user-facing error
        showToast('Data loading error', 'red');
      }
    }

    // main init
    auth.onAuthStateChanged(async (u) => {
      if (!u) {
        window.location.href = '/login';
        return;
      }
      currentUser = u;
      const emailArg = getProfileParam();
      viewedEmail = emailArg || currentUser.email;

      // reset permission tracking (fresh view)
      for (const k in permissionDeniedFor) delete permissionDeniedFor[k];

      // remove old listeners (if any)
      clearUnsubscribes();

      // set up snapshot listeners for the viewed profile and relationship docs
      setupListenersForViewedEmail(viewedEmail);
    });

    // helper to check whether a specific action should be disabled due to permission issues
    function isActionDisabled(reason){
      // reasons: 'follow', 'friend', 'post', 'block' (block always allowed UI-wise), 'report'
      if (reason === 'follow') return !!(permissionDeniedFor.followers || permissionDeniedFor.following || permissionDeniedFor.followDoc);
      if (reason === 'friend') return !!(permissionDeniedFor.friends || permissionDeniedFor.friendDocs || permissionDeniedFor.requests);
      if (reason === 'post') return !!permissionDeniedFor.posts;
      return false;
    }

    // set up all listeners for viewed email
    function setupListenersForViewedEmail(emailArg){
      if (!emailArg) return;

      const fallback = fallbackProfile(emailArg);

      // interactions area visibility (hide only if viewing your own profile)
      if (currentUser && currentUser.email === emailArg) {
        interactionArea.style.display = 'none';
      } else {
        interactionArea.style.display = 'block';
      }

      // user_data doc for viewed user
      const viewedUserDocRef = db.collection('user_data').doc(docIdFromEmail(emailArg));
      const unsubViewedUser = viewedUserDocRef.onSnapshot(snap => {
        const data = snap.exists ? snap.data() : null;
        viewedData = {
          displayName: data && (data['display name'] || data.displayName || data.display_name) ? (data['display name'] || data.displayName || data.display_name) : fallback.displayName,
          email: emailArg,
          profile_picture: data && data.profile_picture ? data.profile_picture : (data && data.profile_picture_url ? data.profile_picture_url : fallback.profile_picture),
          banner: data && data.banner ? data.banner : (data && data.banner_url ? data.banner_url : fallback.banner),
          roles: data && (Array.isArray(data.roles) ? data.roles : (data.role ? [data.role] : fallback.roles)),
          bio: data && data.bio ? data.bio : fallback.bio,
          is_verified: data && data.is_verified ? !!data.is_verified : false,
          profile_picture_frame: data && data.profile_picture_frame ? data.profile_picture_frame : ''
        };

        // UI set
        bannerEl.style.backgroundImage = `url(${viewedData.banner})`;
        profilePicEl.style.backgroundImage = `url(${viewedData.profile_picture})`;
        displayNameEl.textContent = viewedData.displayName || fallback.displayName;
        emailEl.textContent = viewedData.email;
        bioTextEl.textContent = viewedData.bio;
        verifiedEl.style.display = viewedData.is_verified ? 'inline-block' : 'none';
        if (viewedData.profile_picture_frame) { pfpFrameEl.style.backgroundImage = `url(${viewedData.profile_picture_frame})`; pfpFrameEl.style.display = 'block'; } else { pfpFrameEl.style.display = 'none'; }

        // roles render using roleMap icons when present
        rolesList.innerHTML = '';
        (viewedData.roles || ['Member']).forEach(r => {
          const el = document.createElement('div');
          el.className = 'role-item muted';
          if (roleMap[r]) {
            const img = document.createElement('img'); img.src = roleMap[r].icon; img.alt = r;
            img.title = `${r} — ${roleMap[r].desc}`;
            el.appendChild(img);
            const txt = document.createElement('div'); txt.textContent = r;
            el.appendChild(txt);
          } else {
            el.textContent = r; // role without icon
          }
          rolesList.appendChild(el);
        });

        // details / last updated
        detailsList.innerHTML = '';
        const dlist = [
          `<div><strong>Profile email:</strong> ${escapeHtml(viewedData.email)}</div>`,
          `<div><strong>Verified:</strong> ${viewedData.is_verified ? 'Yes' : 'No'}</div>`
        ];
        detailsList.innerHTML = dlist.join('');

        if (snap.exists && snap.data().last_updated) {
          const lu = snap.data().last_updated;
          const d = new Date(lu.seconds ? lu.seconds * 1000 : lu);
          lastUpdatedEl.textContent = 'Updated: ' + d.toLocaleString();
        } else lastUpdatedEl.textContent = '';

        // clear any previous permission flag for this listener if it succeeded
        if (permissionDeniedFor.viewedUser) delete permissionDeniedFor.viewedUser;
        renderInteractionButtons();

      }, err => {
        handleFirestoreError(err, emailArg, 'viewedUser');
      });
      unsubscribes.push(unsubViewedUser);

      // followers / following / friends counters: collection listeners
      const followersColRef = db.collection('followers').doc(docIdFromEmail(emailArg)).collection('usersWhoFollowMe');
      const unsubFollowers = followersColRef.onSnapshot(snap => {
        followersCountEl.textContent = `Followers: ${snap.size || 0}`;
        if (permissionDeniedFor.followers) delete permissionDeniedFor.followers;
      }, err => { handleFirestoreError(err, emailArg, 'followers'); followersCountEl.textContent = 'Followers: 0'; });
      unsubscribes.push(unsubFollowers);

      const followingColRef = db.collection('following').doc(docIdFromEmail(emailArg)).collection('usersIFollow');
      const unsubFollowing = followingColRef.onSnapshot(snap => {
        followingCountEl.textContent = `Following: ${snap.size || 0}`;
        if (permissionDeniedFor.following) delete permissionDeniedFor.following;
      }, err => { handleFirestoreError(err, emailArg, 'following'); followingCountEl.textContent = 'Following: 0'; });
      unsubscribes.push(unsubFollowing);

      const friendsColRef = db.collection('friends').doc(docIdFromEmail(emailArg)).collection('friendlist');
      const unsubFriends = friendsColRef.onSnapshot(snap => {
        friendsCountEl.textContent = `Friends: ${snap.size || 0}`;
        if (permissionDeniedFor.friends) delete permissionDeniedFor.friends;
      }, err => { handleFirestoreError(err, emailArg, 'friends'); friendsCountEl.textContent = 'Friends: 0'; });
      unsubscribes.push(unsubFriends);

      // current user's user_data (for blockedUsers)
      if (currentUser) {
        const currentUserRef = db.collection('user_data').doc(docIdFromEmail(currentUser.email));
        const unsubCurrentUser = currentUserRef.onSnapshot(snap => {
          const data = snap.exists ? snap.data() : {};
          relationshipState.isBlockedByCurrent = Array.isArray(data.blockedUsers) && data.blockedUsers.includes(emailArg);
          // hide interactions if currentUser is viewing self
          if (currentUser.email === emailArg) interactionArea.style.display = 'none';
          // clear permission flag if it was a transient issue
          if (permissionDeniedFor.currentUser) delete permissionDeniedFor.currentUser;
          renderInteractionButtons();
        }, err => { handleFirestoreError(err, emailArg, 'currentUser'); });
        unsubscribes.push(unsubCurrentUser);
      }

      // other user's user_data (to detect if they blocked current)
      const otherUserRef = db.collection('user_data').doc(docIdFromEmail(emailArg));
      const unsubOtherUser = otherUserRef.onSnapshot(snap => {
        const data = snap.exists ? snap.data() : {};
        relationshipState.hasBlockedCurrent = Array.isArray(data.blockedUsers) && currentUser ? data.blockedUsers.includes(currentUser.email) : false;
        if (permissionDeniedFor.otherUser) delete permissionDeniedFor.otherUser;
        renderInteractionButtons();
      }, err => { handleFirestoreError(err, emailArg, 'otherUser'); });
      unsubscribes.push(unsubOtherUser);

      // relationship doc listeners (many small doc listeners):
      if (currentUser) {
        const currentId = docIdFromEmail(currentUser.email);
        const otherId = docIdFromEmail(emailArg);

        const followDocRef = db.collection('following').doc(currentId).collection('usersIFollow').doc(otherId);
        const unsubFollowDoc = followDocRef.onSnapshot(snap => {
          relationshipState.isFollowing = snap.exists;
          if (permissionDeniedFor.followDoc) delete permissionDeniedFor.followDoc;
          renderInteractionButtons();
        }, err => { handleFirestoreError(err, emailArg, 'followDoc'); });
        unsubscribes.push(unsubFollowDoc);

        const followedByDocRef = db.collection('followers').doc(currentId).collection('usersWhoFollowMe').doc(otherId);
        const unsubFollowedByDoc = followedByDocRef.onSnapshot(snap => {
          relationshipState.isFollowedBy = snap.exists;
          if (permissionDeniedFor.followedByDoc) delete permissionDeniedFor.followedByDoc;
          renderInteractionButtons();
        }, err => { handleFirestoreError(err, emailArg, 'followedByDoc'); });
        unsubscribes.push(unsubFollowedByDoc);

        const friendARef = db.collection('friends').doc(currentId).collection('friendlist').doc(otherId);
        const unsubFriendA = friendARef.onSnapshot(snap => {
          renderInteractionButtons();
        }, err => { handleFirestoreError(err, emailArg, 'friendA'); });
        unsubscribes.push(unsubFriendA);

        const friendBRef = db.collection('friends').doc(otherId).collection('friendlist').doc(currentId);
        const unsubFriendB = friendBRef.onSnapshot(async snap => {
          try {
            const aSnap = await db.collection('friends').doc(currentId).collection('friendlist').doc(otherId).get();
            const bSnap = await db.collection('friends').doc(otherId).collection('friendlist').doc(currentId).get();
            relationshipState.friendExists = aSnap.exists && bSnap.exists;
            if (permissionDeniedFor.friendDocs) delete permissionDeniedFor.friendDocs;
          } catch(e) {
            if (isFirestorePermissionError(e)) {
              // mark friend_docs as denied so friend actions get disabled but keep UI available
              permissionDeniedFor.friendDocs = true;
              relationshipState.friendExists = false;
              handleFirestoreError(e, emailArg, 'friendDocs');
            } else {
              console.error('friend exists check failed', e);
              relationshipState.friendExists = false;
            }
          }
          renderInteractionButtons();
        }, err => { handleFirestoreError(err, emailArg, 'friendDocs'); });
        unsubscribes.push(unsubFriendB);

        // requests
        const requestSentRef = db.collection('friends').doc(currentId).collection('requests').doc(otherId);
        const unsubRequestSent = requestSentRef.onSnapshot(snap => {
          relationshipState.requestSent = snap.exists;
          if (permissionDeniedFor.requests) delete permissionDeniedFor.requests;
          renderInteractionButtons();
        }, err => { handleFirestoreError(err, emailArg, 'requests'); });
        unsubscribes.push(unsubRequestSent);

        const requestReceivedRef = db.collection('friends').doc(otherId).collection('requests').doc(currentId);
        const unsubRequestReceived = requestReceivedRef.onSnapshot(snap => {
          relationshipState.requestReceived = snap.exists;
          if (permissionDeniedFor.requestReceived) delete permissionDeniedFor.requestReceived;
          renderInteractionButtons();
        }, err => { handleFirestoreError(err, emailArg, 'requestReceived'); });
        unsubscribes.push(unsubRequestReceived);
      }

      // initial render (will hide if own profile)
      renderInteractionButtons();
    }

    // escape for simple HTML insertion
    function escapeHtml(s){ return String(s).replace(/[&<>\"']/g, function(m){return {'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":"&#39;"}[m];}); }

    // render the action buttons area based on relationshipState
    function renderInteractionButtons(){
      // if viewing own profile, keep interactions hidden
      if (currentUser && viewedEmail && currentUser.email === viewedEmail) {
        interactionArea.style.display = 'none';
        return;
      } else {
        // always show interaction area for others, even if some listeners lack permission
        interactionArea.style.display = 'block';
      }

      // Clear
      interactionButtons.innerHTML = '';

      const nameForButtons = (viewedData && viewedData.displayName) ? viewedData.displayName : viewedEmail;
      const otherEmailEsc = encodeURIComponent(viewedEmail);

      // Post to Wall (white)
      const postBtn = document.createElement('button');
      postBtn.className = 'btn';
      postBtn.textContent = `Post to Wall`;
      if (isActionDisabled('post')) {
        postBtn.disabled = true; postBtn.title = 'Unavailable due to limited permissions'; postBtn.style.opacity = 0.6;
      } else {
        postBtn.addEventListener('click', () => { window.location.href = `/createpost?wall=${otherEmailEsc}`; });
      }
      interactionButtons.appendChild(postBtn);

      // Follow / Unfollow
      const followBtn = document.createElement('button');
      followBtn.className = 'btn';
      followBtn.id = 'followBtn';
      followBtn.textContent = relationshipState.isFollowing ? `Unfollow ${nameForButtons}` : `Follow ${nameForButtons}`;

      if (relationshipState.isBlockedByCurrent) {
        followBtn.disabled = true;
        followBtn.title = "You have blocked this user — unblock to follow";
        followBtn.style.opacity = 0.6;
      } else if (isFallbackProfile) {
        followBtn.disabled = true;
  followBtn.title = 'Unavailable in limited profile view';
  followBtn.style.opacity = 0.6;
      } else {
        followBtn.addEventListener('click', async () => {
          followBtn.disabled = true;
          try {
            if (relationshipState.isFollowing) {
              // unfollow
              await db.collection('followers').doc(viewedEmail).collection('usersWhoFollowMe').doc(currentUser.email).delete().catch(()=>{});
              await db.collection('following').doc(currentUser.email).collection('usersIFollow').doc(viewedEmail).delete().catch(()=>{});
              showToast('Unfollowed', 'purple');
            } else {
              // follow
              await db.collection('followers').doc(viewedEmail).collection('usersWhoFollowMe').doc(currentUser.email).set({ email: currentUser.email, created: firebase.firestore.FieldValue.serverTimestamp() });
              await db.collection('following').doc(currentUser.email).collection('usersIFollow').doc(viewedEmail).set({ email: viewedEmail, created: firebase.firestore.FieldValue.serverTimestamp() });
              showToast('Following', 'purple');
            }
          } catch (err) {
            console.error('follow/unfollow', err);
            if (isFirestorePermissionError(err)) handleFirestoreError(err, viewedEmail, 'followAction');
            else showToast('Action failed', 'red');
          } finally {
            followBtn.disabled = false;
          }
        });
      }
      interactionButtons.appendChild(followBtn);

      // Friend Request / Accept / Remove Friend
      const friendBtn = document.createElement('button');
      friendBtn.className = 'btn';
      friendBtn.id = 'friendBtn';

      if (relationshipState.friendExists) {
        friendBtn.textContent = `Remove Friend`;
        if (isActionDisabled('friend')) {
          friendBtn.disabled = true; friendBtn.title = 'Unavailable due to limited permissions'; friendBtn.style.opacity = 0.6;
        } else {
          friendBtn.addEventListener('click', async () => {
            if (!confirm(`Remove ${nameForButtons} from friends?`)) return;
            try {
              await db.collection('friends').doc(currentUser.email).collection('friendlist').doc(viewedEmail).delete().catch(()=>{});
              await db.collection('friends').doc(viewedEmail).collection('friendlist').doc(currentUser.email).delete().catch(()=>{});
              showToast('Friend removed', 'purple');
            } catch (err) { console.error('remove friend', err); if (isFirestorePermissionError(err)) handleFirestoreError(err, viewedEmail, 'friendAction'); else showToast('Failed', 'red'); }
          });
        }
      } else if (relationshipState.requestReceived) {
        friendBtn.textContent = `Accept Friend Request`;
        if (isActionDisabled('friend')) {
          friendBtn.disabled = true; friendBtn.title = 'Unavailable due to limited permissions'; friendBtn.style.opacity = 0.6;
        } else {
          friendBtn.addEventListener('click', async () => {
            try {
              await db.collection('friends').doc(viewedEmail).collection('requests').doc(currentUser.email).delete().catch(()=>{});
              await db.collection('friends').doc(currentUser.email).collection('friendlist').doc(viewedEmail).set({ email: viewedEmail, created: firebase.firestore.FieldValue.serverTimestamp() });
              await db.collection('friends').doc(viewedEmail).collection('friendlist').doc(currentUser.email).set({ email: currentUser.email, created: firebase.firestore.FieldValue.serverTimestamp() });
              showToast('Friend request accepted', 'purple');
            } catch (err) { console.error('accept friend', err); if (isFirestorePermissionError(err)) handleFirestoreError(err, viewedEmail, 'friendAction'); else showToast('Failed', 'red'); }
          });
        }
      } else if (relationshipState.requestSent) {
        friendBtn.textContent = `Request Pending`;
        friendBtn.disabled = true;
        friendBtn.title = "You have already sent a friend request";
      } else {
        friendBtn.textContent = `Send Friend Request`;
        if (relationshipState.isBlockedByCurrent) {
          friendBtn.disabled = true;
          friendBtn.title = "You have blocked this user — unblock to send request";
          friendBtn.style.opacity = 0.6;
        } else if (isActionDisabled('friend')) {
          friendBtn.disabled = true; friendBtn.title = 'Unavailable due to limited permissions'; friendBtn.style.opacity = 0.6;
        } else {
          friendBtn.addEventListener('click', async () => {
            try {
              const friendExistsDoc = await db.collection('friends').doc(viewedEmail).collection('friendlist').doc(currentUser.email).get();
              if (friendExistsDoc.exists) { showToast('You are already friends', 'yellow'); return; }

              const alreadySent = await db.collection('friends').doc(currentUser.email).collection('requests').doc(viewedEmail).get();
              if (alreadySent.exists) { showToast('Request already pending', 'yellow'); return; }

              await db.collection('friends').doc(currentUser.email).collection('requests').doc(viewedEmail).set({ from: currentUser.email, to: viewedEmail, created: firebase.firestore.FieldValue.serverTimestamp() });
              showToast('Friend request sent', 'purple');
            } catch (err) { console.error('send request', err); if (isFirestorePermissionError(err)) handleFirestoreError(err, viewedEmail, 'friendAction'); else showToast('Failed', 'red'); }
          });
        }
      }
      interactionButtons.appendChild(friendBtn);

      // Block / Unblock (red text only) - must always be present per requirement
      const blockBtn = document.createElement('button');
      blockBtn.className = 'btn red';
      blockBtn.id = 'blockBtn';
      blockBtn.textContent = relationshipState.isBlockedByCurrent ? `Unblock ${nameForButtons}` : `Block ${nameForButtons}`;
      blockBtn.addEventListener('click', async () => {
        try {
          if (!relationshipState.isBlockedByCurrent) {
            if (!confirm(`Block ${nameForButtons}? This will remove follow/friend links.`)) return;
            // add to blockedUsers array
            await db.collection('user_data').doc(currentUser.email).set({ blockedUsers: firebase.firestore.FieldValue.arrayUnion(viewedEmail) }, { merge: true });
            // delete social links per user rule
            const ops = [
              db.collection('followers').doc(currentUser.email).collection('usersWhoFollowMe').doc(viewedEmail).delete().catch(()=>{}),
              db.collection('following').doc(currentUser.email).collection('usersIFollow').doc(viewedEmail).delete().catch(()=>{}),
              db.collection('friends').doc(currentUser.email).collection('friendlist').doc(viewedEmail).delete().catch(()=>{}),
              db.collection('friends').doc(viewedEmail).collection('friendlist').doc(currentUser.email).delete().catch(()=>{}),
              db.collection('friends').doc(currentUser.email).collection('requests').doc(viewedEmail).delete().catch(()=>{})
            ];
            await Promise.all(ops);
            showToast('User blocked', 'purple');
          } else {
            await db.collection('user_data').doc(currentUser.email).set({ blockedUsers: firebase.firestore.FieldValue.arrayRemove(viewedEmail) }, { merge: true });
            showToast('User unblocked', 'purple');
          }
        } catch (err) {
          console.error('block/unblock', err);
          // don't fallback UI — inform user it's blocked
          if (isFirestorePermissionError(err)) showToast('Blocked: insufficient permissions to change block state', 'red');
          else showToast('Failed', 'red');
        }
      });
      interactionButtons.appendChild(blockBtn);

      // Report (red text only) - always available as navigation
      const reportBtn = document.createElement('button');
      reportBtn.className = 'btn red';
      reportBtn.textContent = `Report ${nameForButtons}`;
      reportBtn.addEventListener('click', () => {
        window.location.href = `/reporabuse?email=${otherEmailEsc}`;
      });
      interactionButtons.appendChild(reportBtn);

      if (relationshipState.hasBlockedCurrent) {
        [postBtn, followBtn, friendBtn].forEach(b => { if (b) { b.disabled = true; b.title = "Action unavailable"; b.style.opacity = 0.6; } });
      }
    }

    // defensive cleanup for leftover edit UI elements
    window.addEventListener('load', () => {
      const uploadEls = document.querySelectorAll('input[type=file], .upload-box, #saveNameBtn, #saveBioBtn');
      uploadEls.forEach(e => e?.remove?.());
      // hide interactions until initial auth check runs
      interactionArea.style.display = 'none';
    });

    // unsubscribe when page unloads
    window.addEventListener('beforeunload', () => clearUnsubscribes());

  </script>
</body>
</html>